# 思路一：暴力
```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <set>
#include <memory>

using namespace std;

const int N = 10000;

int n; // 大臣的人数
int r[N], l[N];
int seq[N]; // seq数组，用来记录顺序，长度为n+1,第一位不记录东西
int min_l = 1000000;

void baoli(int n)
{
    int cpy_num[n + 1];
    memcpy(cpy_num, seq, n * 4 + 4);
    int max = -1;
    int res[n + 1] = {0};
    do
    {
        memset(res, 0, n + 1);
        max = 0;
        // 开始暴力枚举
        for (int i = 1; i < n + 1; i++)
        {
            // 从seq 排列之后的数组进行读取 ,i表示大臣的number
            //  1 3 2
            int res_l = 1;
            for (int j = 0; j < i; j++)
            {
                // j 是计算每一位大臣时，所推进的数组的下标
                res_l *= r[cpy_num[j]];
            }
            res_l /= l[cpy_num[i]];
            res[i] = res_l;
        }
        for (auto e : res)
        {
            if (e > max)
            {
                max = e;
            }
        }
        if (max < min_l)
        {
            min_l = max;
        }
    } while (next_permutation(cpy_num, cpy_num + n));
}

int main()
{

    freopen("in.txt", "r", stdin);

    cin >> n;

    for (int i = 0; i <= n; i++)
    {
        cin >> r[i] >> l[i];
    }
    // 这个数组中，排头是国王，剩下的按正常下标代表大臣

    // 思路一：暴力枚举
    // 枚举不同的sequence，挨个进行计算

    for (int i = 1; i <= n; i++)
    {
        seq[i] = i;
    }
    baoli(n);
    cout << min_l;
    return 0;
}
```

通过暴力枚举每一种结果，并且对每一种结果进行计算对比，最终求出答案，当然结果是超时。

贪心问题，的解决方案：
+ 提出解决方案
+ 证明解决方案

以上都是通过数学手段进行证明。因为只有一个正确的贪心思路，才能写出不超时的代码。

这道国王游戏，最终证明出来的思路：排序的依据是a*b的乘积，谁小谁排前面

```cpp
const int MAXN=1010,MAXM=10010;//注意高精数组开到10000
struct Node{//一个人
	int l,r;
}a[MAXN];

bool cmp(Node aa,Node bb){//排序的比较函数
	return aa.l*aa.r<bb.l*bb.r;//按左右手数的乘积从小到大
}

sort(a+1,a+n+1,cmp);//排序
```

## 题解初步：
```cpp
// 解法二：贪心

struct Node
{
    int r;
    int l;
} dc[N];

// r*l积最大即是最佳排序

int cmp(Node A, Node B)
{
    return A.r * A.l < B.r * B.l;
}

int main()
{

    freopen("in.txt", "r", stdin);
    int n; // 大臣的人数
    cin >> n;

    // 设置国王的左右手
    Node king;
    cin >> king.l >> king.r;

    for (int i = 0; i < n; i++)
    {
        // dc是大臣的左右手，这个数组的大小为n, index 从 0 -> n-1
        cin >> dc[i].l >> dc[i].r;
    }

    // 对这个数组进行排序
    sort(dc, dc + n, cmp);

    int MAXIMUM = 0;

    // 开始计算
    for (int i = 0; i < n; i++)
    {
        // i 是number为i的大臣
        int res_l = king.l;
        for (int j = 0; j < i; j++)
        {
            // 从国王开始进行计算，一直算到这个大臣前面的那一位
            res_l *= dc[j].l;
        }
        res_l /= dc[i].r;
        if (res_l > MAXIMUM)
        {
            MAXIMUM = res_l;
        }
    }
    cout << MAXIMUM;
    return 0;
}
```

这个答案WA了四发，后来尝试开大type，结果还是不行。

从long long 到unsigned long long，每一次的答案都不一样，输出是一长串数字，这个明显超了。

得用高精度进行处理。