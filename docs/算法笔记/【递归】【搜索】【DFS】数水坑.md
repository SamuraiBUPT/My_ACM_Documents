# [USACO10OCT]Lake Counting S

## 题面翻译

由于近期的降雨，雨水汇集在农民约翰的田地不同的地方。我们用一个 $N\times M(1\leq N\leq 100, 1\leq M\leq 100)$ 的网格图表示。每个网格中有水（`W`） 或是旱地（`.`）。一个网格与其周围的八个网格相连，而一组相连的网格视为一个水坑。约翰想弄清楚他的田地已经形成了多少水坑。给出约翰田地的示意图，确定当中有多少水坑。

输入第 $1$ 行：两个空格隔开的整数：$N$ 和 $M$。

第 $2$ 行到第 $N+1$ 行：每行 $M$ 个字符，每个字符是 `W` 或 `.`，它们表示网格图中的一排。字符之间没有空格。

输出一行，表示水坑的数量。

## 样例 #1

### 样例输入 #1

```
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

### 样例输出 #1

```
3
```
# 题目解析
```
W . . . . . . . . W W . 
. W W W . . . . . W W W
. . . . W W . . . W W .
. . . . . . . . . W W .
. . . . . . . . . W . .
. . W . . . . . . W . .
. W . W . . . . . W W .
W . W . W . . . . . W . 
. W . W . . . . . . W .
. . W . . . . . . . W .
```
这里一共有三个水坑，左上角的算一个，左下角的那一个对称性很强的算一个，右侧的狭长的算一个。

个人思路：搜周围九格，如果搜到了是W，就跳转到那个位置。

其实按照这个  右下的方向搜，只用搜：

+ `map_[i][j+1]`
+ `map_[i+1][j]`
+ `map_[i+1][j+1]`

三个位置，搜到了就跳转，直到三个位置都没有W为止。

注意：如果搜到多个，就跳到每一个位置，再分别dfs搜下去

看了题解，发现这种问题叫做：**判断连通块**的问题。

完整、完美代码：
```cpp
#include<cstdio>
using namespace std;
char a[101][101];
int ans;
int n,m;
void dfs(int x,int y){
    a[x][y]='.';    //首先就是把这个地方置为".", 表示遍历过
    int dx,dy;
    for(int i=-1;i<=1;i++){
        for(int j=-1;j<=1;j++){
            dx=x+i; //改变dx dy的值，而不是直接改 x 和 y， 以便这个循环进行dfs
            dy=y+j;
            if(dx>=0&&dx<=n&&dy>=0&&dy<m&&a[dx][dy]=='W'){
                dfs(dx,dy); //不超过边界
            }
        }
    }
    return;
} 
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;i++){
    	scanf("%s",a[i]);//避免换行带来问题这里直接读入字符串
    }
    for(int i=0;i<=n;i++){
        for(int j=0;j<m;j++){
            if(a[i][j]=='W'){//如果是W的话就直接开始遍历
                dfs(i,j);
                ans++;//水潭加一处
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

有关这段代码的讲解：他其实是在搜周围八个格子，搜到了任何一个有水的，就从那个点继续搜。

**问题是：如果回退了，又接着搜，不会陷入死循环吗？**

这里就要看到dfs里面的第一句话

`a[x][y]='.';`搜过的地方记为`.`这样就可以避免循环。

这个代码的第二个精妙的地方在于dfs(i, j)，这个函数并不能改变i j的值，实际上还是会依照那个数组进行遍历，但是会改变dfs遍历中的东西，一路上遍历过的地方，都会变成`.`

所以，其实循环依然会老老实实推进i、j，但是一些地方已经被推平和改变了。

这才是这份dfs代码最精妙的地方。